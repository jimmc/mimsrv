// The auth package implements a simple password mechanism to allow
// authentication of API calls.
// We have a database that stores two fields for each user:
// a userid and a cryptword. The cryptword is generated by concatenating
// the userid with the user's password and taking a sha256sum of that.
// For login, the user enters a userid and a password into the client,
// which generates the cryptword. It then gets the current time in seconds
// since the epoch, converts that number to a decimal string, concatenates
// the cryptword with that string, and takes the sha256sum of that, which it
// sends to the server along with the username.

package auth

import (
  "crypto/sha256"
  "fmt"
  "log"
  "net/http"
  "os"
  "strconv"
  "syscall"
  "time"

  "golang.org/x/crypto/ssh/terminal"
  "github.com/jimmc/mimsrv/users"
)

var (
  timeNow = time.Now
)

type Config struct {
  Prefix string                 // The prefix string used for our API calls
  PasswordFilePath string       // Location of our password database file
  MaxClockSkewSeconds int
}

type Handler struct {
  ApiHandler http.Handler
  config *Config
  users *users.Users
}

func NewHandler(c *Config) Handler {
  h := Handler{config: c}
  err := h.loadPasswordFile()
  if err != nil {
    log.Printf("Error loading password file: %v", err)
    h.users = users.Empty()
  }
  h.initApiHandler()
  initTokens()
  return h
}

func (h *Handler) CreatePasswordFile() error {
  f, err := os.Open(h.config.PasswordFilePath)
  if err == nil || !os.IsNotExist(err) {
    return fmt.Errorf("password file already exists at %s", h.config.PasswordFilePath)
  }
  f, err = os.Create(h.config.PasswordFilePath)
  if err != nil {
    return fmt.Errorf("error creating new password file at %s: %v", h.config.PasswordFilePath, err)
  }
  f.Close()
  return nil
}

// Read a password from the terminal and pass it to UpdatePassword.
func (h *Handler) UpdateUserPassword(userid string) error {
  if !terminal.IsTerminal(syscall.Stdin) {
    return fmt.Errorf("updatePassword option requires terminal for input")
  }
  fmt.Printf("New password: ")
  pw, err := terminal.ReadPassword(syscall.Stdin)
  fmt.Printf("\n")
  if err != nil {
    return fmt.Errorf("Error reading new password: %v", err)
  }
  fmt.Printf("Repeat new password: ")
  pw2, err := terminal.ReadPassword(syscall.Stdin)
  fmt.Printf("\n")
  if err != nil {
    return fmt.Errorf("Error reading new password: %v", err)
  }
  if string(pw2) != string(pw) {
    return fmt.Errorf("Passwords did not match")
  }
  return h.UpdatePassword(userid, string(pw))
}

// Set a password for a user into our password database. We don't save the
// plaintext password, we concatenate the userid with the raw password, take
// the sha256sum of that, and store that in our database.
func (h *Handler) UpdatePassword(userid, password string) error {
  err := h.loadPasswordFile()
  if err != nil {
    return err
  }
  cryptword := h.generateCryptword(userid, password)
  h.setCryptword(userid, cryptword)
  err = h.savePasswordFile()
  if err != nil {
    return err
  }
  return nil
}

func (h *Handler) loadPasswordFile() error {
  users, err := users.LoadFile(h.config.PasswordFilePath)
  if err != nil {
    return err
  }
  h.users = users
  return nil
}

func (h *Handler) savePasswordFile() error {
  return h.users.SaveFile(h.config.PasswordFilePath)
}

func (h *Handler) setCryptword(userid, cryptword string) {
  h.users.SetCryptword(userid, cryptword)
}

// Get the encrypted password for the given user from our previously-loaded password file.
func (h *Handler) getCryptword(userid string) string {
  return h.users.Cryptword(userid)
}

func (h *Handler) generateCryptword(userid, password string) string {
  return sha256sum(userid + "-" + password)
}

func (h *Handler) generateNonceAtTime(userid string, secondsSinceEpoch int64) string {
  cryptword := h.getCryptword(userid)
  shaInput := cryptword + "-" + strconv.FormatInt(secondsSinceEpoch, 10)
  return sha256sum(shaInput)
}

func (h *Handler) nonceIsValidAtTime(userid, nonce string, secondsSinceEpoch int64) bool {
  goodNonce := h.generateNonceAtTime(userid, secondsSinceEpoch)
  if nonce == goodNonce {
    return true
  } else {
    log.Printf("nonce %v does not match goodNonce %v", nonce, goodNonce)
    return false
  }
}

func (h *Handler) nonceIsValidNow(userid, nonce string, seconds int64) bool {
  t := timeNow().Unix()
  delta := t - seconds
  if delta > int64(h.config.MaxClockSkewSeconds) || delta < -int64(h.config.MaxClockSkewSeconds) {
    log.Printf("now=%v, client-time=%v, skew is more than max of %v",
        t, seconds, h.config.MaxClockSkewSeconds)
    return false
  }
  return h.nonceIsValidAtTime(userid, nonce, seconds)
}

func sha256sum(s string) string {
  sum := sha256.Sum256([]byte(s))
  return fmt.Sprintf("%x", sum)
}
